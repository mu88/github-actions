name: 'reusable CI/CD workflow'

on:
  workflow_call:
    inputs:
      sonar-key:
        description: 'The key of the Sonar project to analyze'
        type: string
        required: true
      docker-publish-mode:
        description: 'Whether to publish chiseled Docker images'
        type: string
        required: false
        default: none
      docker-publish-project:
        description: 'The .NET project path to publish via .NET SDK Container Building Tools'
        type: string
        required: false
      dotnet-cache-dependencies-via-lock-file:
        description: 'Whether to cache .NET dependencies using the packages.lock.json file'
        type: boolean
        required: false
        default: true
      dotnet-test-additional-params-unit-integration-tests:
        description: 'Any additional parameters for the .NET unit and integration test run'
        type: string
        required: false
      requires-docker-login:
        description: 'Whether this workflow must access Docker'
        type: boolean
        required: false
        default: false
      sonar-additional-params:
        description: 'Any additional parameters for the .NET Sonar scan'
        type: string
        required: false
        default: '/d:sonar.cs.opencover.reportsPaths=Tests/coverage.opencover.xml /s:$GITHUB_WORKSPACE/SonarQube.Analysis.xml'

    secrets:
      sonar-token:
        description: 'The Sonar token'
        required: true

    outputs:
      is_release:
        description: 'Whether this is a release (i.e. a Git commit starting with "chore(release)") or not'
        value: ${{ jobs.determine-release-information.outputs.is_release }}
      release_version:
        description: 'The release version'
        value: ${{ jobs.determine-release-information.outputs.release_version }}

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: 1

jobs:
  validate_input:
    name: 'Validate input parameters'
    runs-on: ubuntu-latest

    steps:
      - name: Validate docker-publish-mode input
        run: |
          docker_publish_mode=${{ inputs.docker-publish-mode }}
          if [[ $docker_publish_mode != "none" \
                && $docker_publish_mode != "regular" \
                && $docker_publish_mode != "regular_and_chiseled" \
                && $docker_publish_mode != "regular_and_chiseled_extra" \
                && $docker_publish_mode != "chiseled" \
                && $docker_publish_mode != "chiseled_extra" ]]; then
            echo "Invalid docker-publish-mode: $docker_publish_mode"
            exit 1
          fi

  unit_integration_tests_and_sonar:
    name: '.NET Unit & Integration Tests and SonarQube'
    runs-on: ubuntu-latest

    needs: validate_input

    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up .NET
        uses: actions/setup-dotnet@v5
        with:
          cache: ${{ inputs.dotnet-cache-dependencies-via-lock-file }}
          cache-dependency-path: "**/packages.lock.json"
          global-json-file: global.json

      - name: Set up JDK
        uses: actions/setup-java@v5
        with:
          distribution: microsoft
          java-version: 21

      - name: Login to Container registry
        if: inputs.docker-publish-mode != 'none' || inputs.requires-docker-login == true
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore .NET tools
        run: dotnet tool restore

      - name: Restore NuGet dependencies
        run: dotnet restore

      - name: Restore SonarQube packages from cache
        uses: actions/cache@v4
        with:
          key: sonar-${{ runner.os }}
          path: ~/.sonar/cache

      - name: Begin SonarQube scan for .NET
        env:
          ENV_SONAR_TOKEN: ${{ secrets.sonar-token }}
        run: dotnet tool run dotnet-sonarscanner begin /k:${{ inputs.sonar-key }} /o:mu88 /d:sonar.token=${{ env.ENV_SONAR_TOKEN }} ${{ inputs.sonar-additional-params }}

      - name: .NET Build
        run: dotnet build --no-restore

      - name: Run .NET unit and integration tests and collect coverage
        run: |
          dotnet test \
            --no-build \
            --filter 'TestCategory=Unit|TestCategory=Integration' \
            --logger trx \
            /p:CollectCoverage=true \
            /p:CoverletOutputFormat=opencover \
            ${{ inputs.dotnet-test-additional-params-unit-integration-tests }}

      - name: End SonarQube scan for .NET
        env:
          ENV_SONAR_TOKEN: ${{ secrets.sonar-token }}
        run: dotnet tool run dotnet-sonarscanner end /d:sonar.token=${{ env.ENV_SONAR_TOKEN }}

      - name: Publish test report
        uses: dorny/test-reporter@v2
        if: ${{ !cancelled() }} 
        with:
          name: dotnet unit and integration tests
          path: '**/*.trx'
          reporter: dotnet-trx

  performance_tests:
    name: '.NET Performance Tests'
    runs-on: ubuntu-latest

    needs: validate_input

    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up .NET
        uses: actions/setup-dotnet@v5
        with:
          cache: ${{ inputs.dotnet-cache-dependencies-via-lock-file }}
          cache-dependency-path: "**/packages.lock.json"
          global-json-file: global.json

      - name: Login to Container registry
        if: inputs.docker-publish-mode != 'none' || inputs.requires-docker-login == true
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore NuGet dependencies
        run: dotnet restore

      - name: .NET Build
        run: dotnet build --no-restore

      - name: Run .NET performance tests
        run: dotnet test --no-build --filter 'TestCategory=Performance' --logger trx

      - name: Publish test report
        uses: dorny/test-reporter@v2
        if: ${{ !cancelled() }} 
        with:
          name: dotnet performance tests
          path: '**/*.trx'
          reporter: dotnet-trx

  system_tests:
    name: '.NET System Tests'
    runs-on: ubuntu-latest

    needs: validate_input

    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up .NET
        uses: actions/setup-dotnet@v5
        with:
          cache: ${{ inputs.dotnet-cache-dependencies-via-lock-file }}
          cache-dependency-path: "**/packages.lock.json"
          global-json-file: global.json

      - name: Login to Container registry
        if: inputs.docker-publish-mode != 'none' || inputs.requires-docker-login == true
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore NuGet dependencies
        run: dotnet restore

      - name: .NET Build
        run: dotnet build --no-restore

      - name: Run .NET system tests
        run: dotnet test --no-build --filter 'TestCategory=System' --logger trx

      - name: Publish test report
        uses: dorny/test-reporter@v2
        if: ${{ !cancelled() }} 
        with:
          name: dotnet system tests
          path: '**/*.trx'
          reporter: dotnet-trx

  determine-release-information:
    name: 'Determine release information'
    runs-on: ubuntu-latest

    needs: validate_input
    
    outputs:
      is_release: ${{ steps.determine-release-information.outputs.is_release }}
      release_version: ${{ steps.determine-release-information.outputs.release_version }}
    
    steps:
      - name: Determine release information
        id: determine-release-information
        run: |
          if [[ "${{ github.event.head_commit.message }}" =~ ^chore\(release\):\s*(.*) ]]; then
            if [[ "${{ github.ref_name }}" != "${{ github.event.repository.default_branch }}" ]]; then
              echo "Releases must be created on the default branch only."
              exit 1
            fi

            version=${BASH_REMATCH[1]}
            is_release=true
          else
            version=dev
            is_release=false
          fi

          echo "release_version=$version" >> $GITHUB_OUTPUT
          echo "is_release=$is_release" >> $GITHUB_OUTPUT

  docker:
    name: 'Build and push Docker images'
    runs-on: ubuntu-latest
    if: inputs.docker-publish-mode != 'none'

    needs:
      - determine-release-information
      - validate_input

    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up .NET
        uses: actions/setup-dotnet@v5
        with:
          cache: ${{ inputs.dotnet-cache-dependencies-via-lock-file }}
          cache-dependency-path: "**/packages.lock.json"
          global-json-file: global.json

      - name: Login to Container registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore NuGet dependencies
        run: dotnet restore

      - name: Build and push Docker
        run: |
          mkdir -p ${{ runner.temp }}/Provenance

          is_release=${{ needs.determine-release-information.outputs.is_release }}
          version=${{ needs.determine-release-information.outputs.release_version }}
          docker_publish_mode=${{ inputs.docker-publish-mode }}

          if [[ $docker_publish_mode == *"chiseled"* ]]; then
            chiseled_suffix="-chiseled"
            container_family="-noble-chiseled"
            if [[ $docker_publish_mode == *"extra"* ]]; then
              container_family="$container_family-extra"
            fi
          else
            chiseled_suffix=""
            container_family=""
          fi

          echo "chiseled_suffix: $chiseled_suffix"
          echo "Container family: $container_family"

          if [[ $docker_publish_mode == *"regular"* ]]; then
            if [[ $is_release == true ]]; then
              tags="$version;latest"
            else
              tags="$version"
            fi
            
            echo "tags: $tags"

            dotnet publish ${{ inputs.docker-publish-project }} \
              --no-restore \
              /t:PublishContainer \
              -bl:${{ runner.temp }}/Provenance/regular.binlog \
              /p:ContainerImageTags=\"$tags\" \
              /p:ContainerRegistry=ghcr.io \
              --getItem:GeneratedContainer --getProperty:GeneratedImageIndex >> ${{ runner.temp }}/Provenance/regular.json
          fi

          if [[ $docker_publish_mode == *"chiseled"* ]]; then
            current_base_image=$(dotnet msbuild ${{ inputs.docker-publish-project }} -getProperty:ContainerBaseImage)
            base_image="$current_base_image$container_family"

            if [[ $is_release == true ]]; then
              tags="$version$chiseled_suffix;latest$chiseled_suffix"
            else
              tags="$version$chiseled_suffix"
            fi

            echo "tags: $tags"
            echo "base_image: $base_image"

            dotnet publish ${{ inputs.docker-publish-project }} \
              --no-restore \
              /t:PublishContainer \
              -bl:${{ runner.temp }}/Provenance/chiseled.binlog \
              /p:ContainerImageTags=\"$tags\" \
              /p:ContainerBaseImage=\"$base_image\" \
              /p:ContainerRegistry=ghcr.io \
              --getItem:GeneratedContainer --getProperty:GeneratedImageIndex >> ${{ runner.temp }}/Provenance/chiseled.json
          fi

      - name: Upload Docker build artifacts
        uses: actions/upload-artifact@v4
        with:
          path: ${{ runner.temp }}/Provenance/*
