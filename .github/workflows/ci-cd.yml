name: 'reusable CI/CD workflow'

on:
  workflow_call:
    inputs:
      sonar-key:
        description: 'The key of the Sonar project to analyze'
        type: string
        required: true
      docker-attest-provenance-and-sbom:
        description: 'Whether to attest Docker image build provenance and SBOM'
        type: boolean
        required: false
        default: true
      docker-publish-mode:
        description: 'Whether to publish chiseled Docker images'
        type: string
        required: false
        default: none
      docker-publish-project:
        description: 'The .NET project path to publish via .NET SDK Container Building Tools'
        type: string
        required: false
      dotnet-cache-dependencies-via-lock-file:
        description: 'Whether to cache .NET dependencies using the packages.lock.json file'
        type: boolean
        required: false
        default: true
      dotnet-test-additional-params-unit-integration-tests:
        description: 'Any additional parameters for the .NET unit and integration test run'
        type: string
        required: false
      requires-docker-login:
        description: 'Whether this workflow must access Docker'
        type: boolean
        required: false
        default: false
      sonar-additional-params:
        description: 'Any additional parameters for the .NET Sonar scan'
        type: string
        required: false
        default: '/d:sonar.cs.opencover.reportsPaths=Tests/coverage.opencover.xml /s:$GITHUB_WORKSPACE/SonarQube.Analysis.xml'

    secrets:
      sonar-token:
        description: 'The Sonar token'
        required: true

    outputs:
      is_release:
        description: 'Whether this is a release (i.e. a Git commit starting with "chore(release)") or not'
        value: ${{ jobs.determine-release-information.outputs.is_release }}
      release_version:
        description: 'The release version'
        value: ${{ jobs.determine-release-information.outputs.release_version }}

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: 1

jobs:
  validate_input:
    name: 'Validate input parameters'
    runs-on: ubuntu-latest

    steps:
      - name: Validate docker-publish-mode input
        run: |
          docker_publish_mode=${{ inputs.docker-publish-mode }}
          if [[ $docker_publish_mode != "none" \
                && $docker_publish_mode != "regular" \
                && $docker_publish_mode != "regular_and_chiseled" \
                && $docker_publish_mode != "regular_and_chiseled_extra" \
                && $docker_publish_mode != "chiseled" \
                && $docker_publish_mode != "chiseled_extra" ]]; then
            echo "Invalid docker-publish-mode: $docker_publish_mode"
            exit 1
          fi

  unit_integration_tests_and_sonar:
    name: '.NET Unit & Integration Tests and SonarQube'
    runs-on: ubuntu-latest

    needs: validate_input

    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up .NET
        uses: actions/setup-dotnet@v5
        with:
          cache: ${{ inputs.dotnet-cache-dependencies-via-lock-file }}
          cache-dependency-path: "**/packages.lock.json"
          global-json-file: global.json

      - name: Set up JDK
        uses: actions/setup-java@v5
        with:
          distribution: microsoft
          java-version: 21

      - name: Login to Container registry
        if: inputs.docker-publish-mode != 'none' || inputs.requires-docker-login == true
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore .NET tools
        run: dotnet tool restore

      - name: Restore NuGet dependencies
        run: dotnet restore

      - name: Restore SonarQube packages from cache
        uses: actions/cache@v4
        with:
          key: sonar-${{ runner.os }}
          path: ~/.sonar/cache

      - name: Begin SonarQube scan for .NET
        env:
          ENV_SONAR_TOKEN: ${{ secrets.sonar-token }}
        run: dotnet tool run dotnet-sonarscanner begin /k:${{ inputs.sonar-key }} /o:mu88 /d:sonar.token=${{ env.ENV_SONAR_TOKEN }} ${{ inputs.sonar-additional-params }}

      - name: .NET Build
        run: dotnet build --no-restore

      - name: Run .NET unit and integration tests and collect coverage
        run: |
          dotnet test \
            --no-build \
            --filter 'TestCategory=Unit|TestCategory=Integration' \
            --logger trx \
            /p:CollectCoverage=true \
            /p:CoverletOutputFormat=opencover \
            ${{ inputs.dotnet-test-additional-params-unit-integration-tests }}

      - name: End SonarQube scan for .NET
        env:
          ENV_SONAR_TOKEN: ${{ secrets.sonar-token }}
        run: dotnet tool run dotnet-sonarscanner end /d:sonar.token=${{ env.ENV_SONAR_TOKEN }}

      - name: Publish test report
        uses: dorny/test-reporter@v2
        if: ${{ !cancelled() }} 
        with:
          name: dotnet unit and integration tests
          path: '**/*.trx'
          reporter: dotnet-trx

  performance_tests:
    name: '.NET Performance Tests'
    runs-on: ubuntu-latest

    needs: validate_input

    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up .NET
        uses: actions/setup-dotnet@v5
        with:
          cache: ${{ inputs.dotnet-cache-dependencies-via-lock-file }}
          cache-dependency-path: "**/packages.lock.json"
          global-json-file: global.json

      - name: Login to Container registry
        if: inputs.docker-publish-mode != 'none' || inputs.requires-docker-login == true
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore NuGet dependencies
        run: dotnet restore

      - name: .NET Build
        run: dotnet build --no-restore

      - name: Run .NET performance tests
        run: dotnet test --no-build --filter 'TestCategory=Performance' --logger trx

      - name: Publish test report
        uses: dorny/test-reporter@v2
        if: ${{ !cancelled() }} 
        with:
          name: dotnet performance tests
          path: '**/*.trx'
          reporter: dotnet-trx

  system_tests:
    name: '.NET System Tests'
    runs-on: ubuntu-latest

    needs: validate_input

    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up .NET
        uses: actions/setup-dotnet@v5
        with:
          cache: ${{ inputs.dotnet-cache-dependencies-via-lock-file }}
          cache-dependency-path: "**/packages.lock.json"
          global-json-file: global.json

      - name: Login to Container registry
        if: inputs.docker-publish-mode != 'none' || inputs.requires-docker-login == true
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore NuGet dependencies
        run: dotnet restore

      - name: .NET Build
        run: dotnet build --no-restore

      - name: Run .NET system tests
        run: dotnet test --no-build --filter 'TestCategory=System' --logger trx

      - name: Publish test report
        uses: dorny/test-reporter@v2
        if: ${{ !cancelled() }} 
        with:
          name: dotnet system tests
          path: '**/*.trx'
          reporter: dotnet-trx

  determine-release-information:
    name: 'Determine release information'
    runs-on: ubuntu-latest

    needs: validate_input
    
    outputs:
      is_release: ${{ steps.determine-release-information.outputs.is_release }}
      release_version: ${{ steps.determine-release-information.outputs.release_version }}
    
    steps:
      - name: Determine release information
        id: determine-release-information
        run: |
          if [[ "${{ github.event.head_commit.message }}" =~ ^chore\(release\):\s*(.*) ]]; then
            if [[ "${{ github.ref_name }}" != "${{ github.event.repository.default_branch }}" ]]; then
              echo "Releases must be created on the default branch only."
              exit 1
            fi

            version=${BASH_REMATCH[1]}
            is_release=true
          else
            version=dev
            is_release=false
          fi

          echo "release_version=$version" >> $GITHUB_OUTPUT
          echo "is_release=$is_release" >> $GITHUB_OUTPUT

  docker:
    name: 'Build and push Docker images'
    runs-on: ubuntu-latest
    if: inputs.docker-publish-mode != 'none'

    needs:
      - determine-release-information
      - validate_input

    outputs:
      digests: ${{ steps.extract-digests.outputs.digests }}
      image_name: ${{ steps.determine-image-name.outputs.image_name }}

    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up .NET
        uses: actions/setup-dotnet@v5
        with:
          cache: ${{ inputs.dotnet-cache-dependencies-via-lock-file }}
          cache-dependency-path: "**/packages.lock.json"
          global-json-file: global.json

      - name: Login to Container registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine Docker image name
        id: determine-image-name
        run: |
          image_name=$(dotnet msbuild ${{ inputs.docker-publish-project }} -getProperty:ContainerRepository)
          echo "image_name=$image_name" >> $GITHUB_OUTPUT

      - name: Restore NuGet dependencies
        run: dotnet restore

      - name: Build and push Docker
        id: build-and-push-docker
        run: |
          mkdir -p ${{ runner.temp }}/Provenance

          is_release=${{ needs.determine-release-information.outputs.is_release }}
          version=${{ needs.determine-release-information.outputs.release_version }}
          docker_publish_mode=${{ inputs.docker-publish-mode }}
          all_tags=""

          if [[ $docker_publish_mode == *"chiseled"* ]]; then
            chiseled_suffix="-chiseled"
            container_family="-noble-chiseled"
            if [[ $docker_publish_mode == *"extra"* ]]; then
              container_family="$container_family-extra"
            fi
          else
            chiseled_suffix=""
            container_family=""
          fi

          echo "chiseled_suffix: $chiseled_suffix"
          echo "Container family: $container_family"

          if [[ $docker_publish_mode == *"regular"* ]]; then
            if [[ $is_release == true ]]; then
              tags="$version;latest"
            else
              tags="$version"
            fi
            
            echo "tags: $tags"

            all_tags="$tags"

            dotnet publish ${{ inputs.docker-publish-project }} \
              --no-restore \
              /t:PublishContainer \
              /p:ContainerImageTags=\"$tags\" \
              /p:ContainerRegistry=ghcr.io \
              --getItem:GeneratedContainer --getProperty:GeneratedImageIndex >> ${{ runner.temp }}/Provenance/regular.json
          fi

          if [[ $docker_publish_mode == *"chiseled"* ]]; then
            current_base_image=$(dotnet msbuild ${{ inputs.docker-publish-project }} -getProperty:ContainerBaseImage)
            base_image="$current_base_image$container_family"

            if [[ $is_release == true ]]; then
              tags="$version$chiseled_suffix;latest$chiseled_suffix"
            else
              tags="$version$chiseled_suffix"
            fi

            echo "tags: $tags"
            echo "base_image: $base_image"

            if [[ -n "$all_tags" ]]; then
              all_tags="$all_tags;$tags"
            else
              all_tags="$tags"
            fi

            dotnet publish ${{ inputs.docker-publish-project }} \
              --no-restore \
              /t:PublishContainer \
              /p:ContainerImageTags=\"$tags\" \
              /p:ContainerBaseImage=\"$base_image\" \
              /p:ContainerRegistry=ghcr.io \
              --getItem:GeneratedContainer --getProperty:GeneratedImageIndex >> ${{ runner.temp }}/Provenance/chiseled.json
          fi

          echo "all_tags=$all_tags" >> $GITHUB_OUTPUT

      - name: Extract generated Docker image digests
        if: inputs.docker-attest-provenance-and-sbom == true
        id: extract-digests
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $PSNativeCommandUseErrorActionPreference = $true

          $allTags = '${{ steps.build-and-push-docker.outputs.all_tags }}'
          $inputDirectory = '${{ runner.temp }}/Provenance/'
          $digests = New-Object System.Collections.Generic.List[string]

          function Get-DigestsFromObject {
            param($obj)

            if ($null -eq $obj) {
              return
            }

            # If it's an enumerable (array/list) but not a string, iterate
            if ($obj -is [System.Collections.IEnumerable] -and -not ($obj -is [string])) {
              foreach ($item in $obj) {
                Get-DigestsFromObject $item
              }

              return
            }

            # If it's a PSCustomObject / has properties, inspect properties
            if ($obj -is [psobject]) {
              foreach ($p in $obj.PSObject.Properties) {
                if ($p.Name -eq 'digest') {
                  if ($p.Value -ne $null) {
                    $digests.Add([string]$p.Value)
                  }
                } else {
                  Get-DigestsFromObject $p.Value
                }
              }

              return
            }

            # If it's a string, it might be nested JSON (possibly with \uXXXX escapes)
            if ($obj -is [string]) {
              $s = $obj.Trim()
              if ($s -match '\\u[0-9A-Fa-f]{4}' -or $s.StartsWith('{') -or $s.StartsWith('[')) {
                # Convert Unicode escapes like \u0022 into characters
                $unescaped = [regex]::Replace($s, '\\u([0-9A-Fa-f]{4})', { param($m) [char]([convert]::ToInt32($m.Groups[1].Value,16)) })

                try {
                  $inner = $unescaped | ConvertFrom-Json -ErrorAction Stop
                  Get-DigestsFromObject $inner
                } catch {
                  # not valid JSON even after unescaping; ignore
                }
              }
            }
          }

          $files = Get-ChildItem -Path $inputDirectory -Filter '*.json' -File | ForEach-Object { $_.FullName }
          foreach ($f in $files) {
            if (Test-Path $f) {
              $raw = Get-Content -Raw -ErrorAction SilentlyContinue -Path $f
              if ($null -ne $raw -and $raw.Trim().Length -gt 0) {
                try {
                  $root = $raw | ConvertFrom-Json -ErrorAction Stop
                  Get-DigestsFromObject $root
                } catch {
                  # If the top-level file isn't valid JSON, skip
                }
              }
            }
          }


          foreach ($tag in $allTags.split(';')) {
            $imageName = '${{ steps.determine-image-name.outputs.image_name }}'
            $fullImageRef = "ghcr.io/$($imageName):$tag"
            docker pull $fullImageRef | Out-Null
            $digestOutput = docker inspect --format='{{index .RepoDigests 0}}' $fullImageRef | ForEach-Object {
              if ($_ -match '@(sha256:[a-f0-9]{64})$') {
                return $Matches[1]
              } else {
                return $null
              }
            }
            if (-not [string]::IsNullOrWhiteSpace($digestOutput)) {
              $digests.Add($digestOutput.Trim())
            }
          }

          # Deduplicate while preserving order
          $uniq = New-Object System.Collections.Generic.List[string]
          $seen = [System.Collections.Generic.HashSet[string]]::new()
          foreach ($d in $digests) {
            if ([string]::IsNullOrWhiteSpace($d)) {
              continue
            }

            if (-not $seen.Contains($d)) {
              $null = $seen.Add($d)
              $uniq.Add($d)
            }
          }

          if ($uniq.Count -eq 0) {
            $json = '[]'
          } else {
            $json = ($uniq | ConvertTo-Json -Compress)
          }

          Write-Output "digests=$json" >> $env:GITHUB_OUTPUT

  attest_provenance_sbom:
    name: 'Attest Docker image build provenance and SBOM'
    runs-on: ubuntu-latest
    if: inputs.docker-publish-mode != 'none' && inputs.docker-attest-provenance-and-sbom == true

    needs:
      - determine-release-information
      - docker

    strategy:
      matrix:
        digest: ${{ fromJson(needs.docker.outputs.digests) }}

    steps:
      - name: Login to Container registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Attest build provenance
        uses: actions/attest-build-provenance@v3
        with:
          push-to-registry: true
          subject-name: ghcr.io/${{ needs.docker.outputs.image_name }}
          subject-digest: ${{ matrix.digest }}

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ghcr.io/${{ needs.docker.outputs.image_name }}@${{ matrix.digest }}
          output-file: sbom.json

      - name: Attest SBOM
        uses: actions/attest-sbom@v3
        with:
          push-to-registry: true
          sbom-path: sbom.json
          subject-name: ghcr.io/${{ needs.docker.outputs.image_name }}
          subject-digest: ${{ matrix.digest }}
