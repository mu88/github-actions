name: 'reusable CI/CD workflow'

on:
  workflow_call:
    inputs:
      sonar-key:
        description: 'The key of the Sonar project to analyze'
        type: string
        required: true
      docker-attest-provenance-and-sbom:
        description: 'Whether to attest Docker image build provenance and SBOM'
        type: boolean
        required: false
        default: true
      docker-publish-project:
        description: 'The .NET project path to publish via .NET SDK Container Building Tools'
        type: string
        required: false
      dotnet-cache-dependencies-via-lock-file:
        description: 'Whether to cache .NET dependencies using the packages.lock.json file'
        type: boolean
        required: false
        default: true
      dotnet-test-additional-params-unit-integration-tests:
        description: 'Any additional parameters for the .NET unit and integration test run'
        type: string
        required: false
      requires-docker-login:
        description: 'Whether this workflow must access Docker'
        type: boolean
        required: false
        default: false
      sonar-additional-params:
        description: 'Any additional parameters for the .NET Sonar scan'
        type: string
        required: false
        default: '/d:sonar.cs.opencover.reportsPaths=Tests/coverage.opencover.xml /s:$GITHUB_WORKSPACE/SonarQube.Analysis.xml'

    secrets:
      sonar-token:
        description: 'The Sonar token'
        required: true

    outputs:
      is_release:
        description: 'Whether this is a release (i.e. a Git commit starting with "chore(release)") or not'
        value: ${{ jobs.determine-release-information.outputs.is_release }}
      release_version:
        description: 'The release version'
        value: ${{ jobs.determine-release-information.outputs.release_version }}

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: 1

jobs:
  determine_docker_publish_needed:
    name: 'Determine whether Docker publish is needed'
    runs-on: ubuntu-latest

    outputs:
      docker-publish-needed: ${{ steps.determine-docker-publish-mode.outputs.docker-publish-needed }}

    steps:
      - name: Determine Docker publish needed
        id: determine-docker-publish-mode
        shell: pwsh
        run: |
          if ([string]::IsNullOrWhiteSpace("${{ inputs.docker-publish-project }}")) {
            Write-Output "docker-publish-needed=false" >> $env:GITHUB_OUTPUT
          } else {
            Write-Output "docker-publish-needed=true" >> $env:GITHUB_OUTPUT
          }

  unit_integration_tests_and_sonar:
    name: '.NET Unit & Integration Tests and SonarQube'
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up .NET
        uses: actions/setup-dotnet@v5
        with:
          cache: ${{ inputs.dotnet-cache-dependencies-via-lock-file }}
          cache-dependency-path: "**/packages.lock.json"
          global-json-file: global.json

      - name: Set up JDK
        uses: actions/setup-java@v5
        with:
          distribution: microsoft
          java-version: 21

      - name: Login to Container registry
        if: inputs.requires-docker-login == true
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore .NET tools
        run: dotnet tool restore

      - name: Restore NuGet dependencies
        run: dotnet restore

      - name: Restore SonarQube packages from cache
        uses: actions/cache@v4
        with:
          key: sonar-${{ runner.os }}
          path: ~/.sonar/cache

      - name: Begin SonarQube scan for .NET
        env:
          ENV_SONAR_TOKEN: ${{ secrets.sonar-token }}
        run: dotnet tool run dotnet-sonarscanner begin /k:${{ inputs.sonar-key }} /o:mu88 /d:sonar.token=${{ env.ENV_SONAR_TOKEN }} ${{ inputs.sonar-additional-params }}

      - name: .NET Build
        run: dotnet build --no-restore

      - name: Run .NET unit and integration tests and collect coverage
        run: |
          dotnet test \
            --no-build \
            --filter 'TestCategory=Unit|TestCategory=Integration' \
            --logger trx \
            /p:CollectCoverage=true \
            /p:CoverletOutputFormat=opencover \
            ${{ inputs.dotnet-test-additional-params-unit-integration-tests }}

      - name: End SonarQube scan for .NET
        env:
          ENV_SONAR_TOKEN: ${{ secrets.sonar-token }}
        run: dotnet tool run dotnet-sonarscanner end /d:sonar.token=${{ env.ENV_SONAR_TOKEN }}

      - name: Publish test report
        uses: dorny/test-reporter@v2
        if: ${{ !cancelled() }} 
        with:
          name: dotnet unit and integration tests
          path: '**/*.trx'
          reporter: dotnet-trx

  performance_tests:
    name: '.NET Performance Tests'
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up .NET
        uses: actions/setup-dotnet@v5
        with:
          cache: ${{ inputs.dotnet-cache-dependencies-via-lock-file }}
          cache-dependency-path: "**/packages.lock.json"
          global-json-file: global.json

      - name: Login to Container registry
        if: inputs.requires-docker-login == true
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore NuGet dependencies
        run: dotnet restore

      - name: .NET Build
        run: dotnet build --no-restore

      - name: Run .NET performance tests
        run: dotnet test --no-build --filter 'TestCategory=Performance' --logger trx

      - name: Publish test report
        uses: dorny/test-reporter@v2
        if: ${{ !cancelled() }} 
        with:
          name: dotnet performance tests
          path: '**/*.trx'
          reporter: dotnet-trx

  system_tests:
    name: '.NET System Tests'
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up .NET
        uses: actions/setup-dotnet@v5
        with:
          cache: ${{ inputs.dotnet-cache-dependencies-via-lock-file }}
          cache-dependency-path: "**/packages.lock.json"
          global-json-file: global.json

      - name: Login to Container registry
        if: inputs.requires-docker-login == true
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore NuGet dependencies
        run: dotnet restore

      - name: .NET Build
        run: dotnet build --no-restore

      - name: Run .NET system tests
        run: dotnet test --no-build --filter 'TestCategory=System' --logger trx

      - name: Publish test report
        uses: dorny/test-reporter@v2
        if: ${{ !cancelled() }} 
        with:
          name: dotnet system tests
          path: '**/*.trx'
          reporter: dotnet-trx

  determine-release-information:
    name: 'Determine release information'
    runs-on: ubuntu-latest
    
    outputs:
      is_release: ${{ steps.determine-release-information.outputs.is_release }}
      release_version: ${{ steps.determine-release-information.outputs.release_version }}
    
    steps:
      - name: Determine release information
        id: determine-release-information
        shell: pwsh
        run: |
          $commitMsg = "${{ github.event.head_commit.message }}"
          $defaultBranch = "${{ github.event.repository.default_branch }}"
          $refName = "${{ github.ref_name }}"

          $regex = '^chore\(release\):\s*(.*)'
          $isRelease = $false
          $version = 'dev'

          if ($commitMsg -match $regex) {
            if ($refName -ne $defaultBranch) {
              Write-Host "Releases must be created on the default branch only."
              exit 1
            }
            $version = $Matches[1]
            $isRelease = $true
          }

          Write-Host "release_version=$version"
          Write-Output "release_version=$version" >> $env:GITHUB_OUTPUT
          Write-Output "is_release=$isRelease" >> $env:GITHUB_OUTPUT

  docker:
    name: 'Build and push Docker images'
    runs-on: ubuntu-latest
    if: needs.determine_docker_publish_needed.outputs.docker-publish-needed == 'true'

    needs:
      - determine_docker_publish_needed
      - determine-release-information

    outputs:
      digests: ${{ steps.extract-digests.outputs.digests }}
      image_name: ${{ steps.determine-image-name.outputs.image_name }}

    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up .NET
        uses: actions/setup-dotnet@v5
        with:
          cache: ${{ inputs.dotnet-cache-dependencies-via-lock-file }}
          cache-dependency-path: "**/packages.lock.json"
          global-json-file: global.json

      - name: Login to Container registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine Docker image name
        id: determine-image-name
        run: |
          image_name=$(dotnet msbuild ${{ inputs.docker-publish-project }} -getProperty:ContainerRepository)
          echo "image_name=$image_name" >> $GITHUB_OUTPUT

      - name: Restore NuGet dependencies
        run: dotnet restore

      - name: Build and push Docker
        id: build-and-push-docker
        run: |
          mkdir -p ${{ runner.temp }}/Provenance
          dotnet publish ${{ inputs.docker-publish-project }} \
            --no-restore \
            /t:PublishContainersForMultipleFamilies \
            -p:ReleaseVersion=${{ needs.determine-release-information.outputs.release_version }} \
            -p:IsRelease=${{ needs.determine-release-information.outputs.is_release }}

      - name: Extract generated Docker image digests
        if: inputs.docker-attest-provenance-and-sbom == true
        id: extract-digests
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $PSNativeCommandUseErrorActionPreference = $true

          $allTags = '${{ steps.build-and-push-docker.outputs.all_tags }}'
          $inputDirectory = '${{ runner.temp }}/Provenance/'
          $digests = New-Object System.Collections.Generic.List[string]

          function Get-DigestsFromObject {
            param($obj)

            if ($null -eq $obj) {
              return
            }

            # If it's an enumerable (array/list) but not a string, iterate
            if ($obj -is [System.Collections.IEnumerable] -and -not ($obj -is [string])) {
              foreach ($item in $obj) {
                Get-DigestsFromObject $item
              }

              return
            }

            # If it's a PSCustomObject / has properties, inspect properties
            if ($obj -is [psobject]) {
              foreach ($p in $obj.PSObject.Properties) {
                if ($p.Name -eq 'digest') {
                  if ($p.Value -ne $null) {
                    $digests.Add([string]$p.Value)
                  }
                } else {
                  Get-DigestsFromObject $p.Value
                }
              }

              return
            }

            # If it's a string, it might be nested JSON (possibly with \uXXXX escapes)
            if ($obj -is [string]) {
              $s = $obj.Trim()
              if ($s -match '\\u[0-9A-Fa-f]{4}' -or $s.StartsWith('{') -or $s.StartsWith('[')) {
                # Convert Unicode escapes like \u0022 into characters
                $unescaped = [regex]::Replace($s, '\\u([0-9A-Fa-f]{4})', { param($m) [char]([convert]::ToInt32($m.Groups[1].Value,16)) })

                try {
                  $inner = $unescaped | ConvertFrom-Json -ErrorAction Stop
                  Get-DigestsFromObject $inner
                } catch {
                  # not valid JSON even after unescaping; ignore
                }
              }
            }
          }

          $files = Get-ChildItem -Path $inputDirectory -Filter '*.json' -File | ForEach-Object { $_.FullName }
          foreach ($f in $files) {
            if (Test-Path $f) {
              $raw = Get-Content -Raw -ErrorAction SilentlyContinue -Path $f
              if ($null -ne $raw -and $raw.Trim().Length -gt 0) {
                try {
                  $root = $raw | ConvertFrom-Json -ErrorAction Stop
                  Get-DigestsFromObject $root
                } catch {
                  # If the top-level file isn't valid JSON, skip
                }
              }
            }
          }


          foreach ($tag in $allTags.split(';')) {
            $imageName = '${{ steps.determine-image-name.outputs.image_name }}'
            $fullImageRef = "ghcr.io/$($imageName):$tag"
            docker pull $fullImageRef | Out-Null
            $digestOutput = docker inspect --format='{{index .RepoDigests 0}}' $fullImageRef | ForEach-Object {
              if ($_ -match '@(sha256:[a-f0-9]{64})$') {
                return $Matches[1]
              } else {
                return $null
              }
            }
            if (-not [string]::IsNullOrWhiteSpace($digestOutput)) {
              $digests.Add($digestOutput.Trim())
            }
          }

          # Deduplicate while preserving order
          $uniq = New-Object System.Collections.Generic.List[string]
          $seen = [System.Collections.Generic.HashSet[string]]::new()
          foreach ($d in $digests) {
            if ([string]::IsNullOrWhiteSpace($d)) {
              continue
            }

            if (-not $seen.Contains($d)) {
              $null = $seen.Add($d)
              $uniq.Add($d)
            }
          }

          if ($uniq.Count -eq 0) {
            $json = '[]'
          } else {
            $json = ($uniq | ConvertTo-Json -Compress)
          }

          Write-Output "digests=$json" >> $env:GITHUB_OUTPUT

  attest_provenance_sbom:
    name: 'Attest Docker image build provenance and SBOM'
    runs-on: ubuntu-latest
    if: inputs.docker-attest-provenance-and-sbom == true && needs.determine_docker_publish_needed.outputs.docker-publish-needed == 'true'

    needs:
      - determine_docker_publish_needed
      - determine-release-information
      - docker

    strategy:
      matrix:
        digest: ${{ fromJson(needs.docker.outputs.digests) }}

    steps:
      - name: Login to Container registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Attest build provenance
        uses: actions/attest-build-provenance@v3
        with:
          push-to-registry: true
          subject-name: ghcr.io/${{ needs.docker.outputs.image_name }}
          subject-digest: ${{ matrix.digest }}

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ghcr.io/${{ needs.docker.outputs.image_name }}@${{ matrix.digest }}
          output-file: sbom.json

      - name: Attest SBOM
        uses: actions/attest-sbom@v3
        with:
          push-to-registry: true
          sbom-path: sbom.json
          subject-name: ghcr.io/${{ needs.docker.outputs.image_name }}
          subject-digest: ${{ matrix.digest }}
